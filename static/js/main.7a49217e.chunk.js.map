{"version":3,"sources":["Square.js","Table.js","PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["Square","props","state","this","isStart","isFinish","isBarrier","isInSearchArea","btnClass","searchAreaClass","isOnShortestPathClass","isOnShortestPath","className","onClick","handleClickOnSquare","id","React","Component","Table","squares","map","row","rowIndex","key","square","squareIndex","PathFinder","solve","visitedSquares","setInfiniteDistanceFromStart","start","getStartingSquare","priorityQueue","push","isFinished","length","sort","a","b","distance","currentSquare","shift","neighbours","getNeighboursOf","i","neighbour","computedDistanceOfNeighbour","previousSquare","hasBeenVisited","col","solveWithHeuristics","heuristics","getDistanceHeuristics","power","finishSquare","getFinishSquare","squareRow","squareCol","finishRow","finishCol","Math","pow","abs","squarePosition","j","Number","MAX_VALUE","startingSquare","filter","squaresInRow","constructShortestPath","shortestPath","tempSquare","reverse","handleSolveClick","algorithmType","alert","animateSolving","then","animateShortestPath","Promise","resolve","setTimeout","setState","eraseSearchAreaWithShortestPath","idOfClickedSquare","oldStartingSquare","oldFinishSquare","selectedSquareType","handleSquareTypeChoice","event","target","value","handleAlgorithmChange","wasSolved","createSquares","chooseSquares","BARRIERS_POSITION","squaresForAnimation","onChange","setInSearchAreaPropertyOfSquare","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.7a49217e.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Square.css\";\n\nclass Square extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  // handleMouseDown = () => {\n  //   console.log(\"working\");\n  // }\n\n  render() {\n    const { isStart, isFinish, isBarrier, isInSearchArea, isOnShortestPath } = this.props;\n\n    let btnClass = isStart\n      ? \"start\"\n      : isFinish\n      ? \"finish\"\n      : isBarrier\n      ? \"barrier\"\n      : \"\";\n\n    let searchAreaClass = \"\";\n    //TODO: Refactor\n    if (btnClass === \"\") {\n      searchAreaClass = isInSearchArea ? \"search-area\" : \"\";\n    }\n\n    let isOnShortestPathClass = \"\"; \n    if(isOnShortestPath){\n      isOnShortestPathClass = \"shortestPath\";\n    }\n\n    return (\n      <button\n        className={`square ${btnClass} ${searchAreaClass} ${isOnShortestPathClass}`}\n        onClick={() => this.props.handleClickOnSquare(this.props.id)}\n        //onMouseDown={ () => this.handleMouseDown()}\n      ></button>\n    );\n  }\n}\n\nexport default Square;\n","import React from \"react\";\nimport Square from \"./Square\";\n\n\nclass Table extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { squares: [] };\n  }\n\n  render() {\n    const { squares } = this.props;\n    return (\n      <div>\n        <div className=\"table\">\n          {squares.map((row, rowIndex) => {\n            return (\n              <div key={rowIndex}>\n                {row.map((square, squareIndex) => {\n                  return (\n                    <Square\n                      key={squareIndex}\n                      id={square.id}\n                      isStart={square.isStart}\n                      isFinish={square.isFinish}\n                      isBarrier={square.isBarrier}\n                      isInSearchArea={square.isInSearchArea}\n                      isOnShortestPath={square.isOnShortestPath}\n                      handleClickOnSquare={this.props.handleClickOnSquare}\n                    ></Square>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>  \n      </div>\n    );\n  }\n}\n\nexport default Table;\n","import React from \"react\";\nimport \"./PathFinder.css\";\nimport Table from \"./Table\";\n\nconst COLS = 19;\nconst ROWS = 19;\n\nclass PathFinder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      squares: [],\n      selectedSquareType: \"start\",\n      wasSolved: false,\n      visitedSquares: [],\n      shortestPath: [],\n      algorithmType: \"dijkstra\",\n    };\n  }\n\n  componentDidMount() {\n    this.createSquares();\n  }\n\n  createSquares() {\n    let squares = [];\n    for (let i = 0; i < COLS; i++) {\n      let squaresInRow = [];\n      for (let j = 0; j < ROWS; j++) {\n        const square = {\n          id: { row: i, col: j },\n          isStart: false,\n          isFinish: false,\n          isBarrier: false,\n          //isInSearchArea: false,\n        };\n        squaresInRow.push(square);\n      }\n      squares.push(squaresInRow);\n    }\n    this.setState({ squares }, this.chooseSquares);\n  }\n\n  chooseSquares() {\n    const START_ROW = 8;\n    const START_COL = 5;\n\n    const FINISH_ROW = 8;\n    const FINISH_COL = 13;\n\n    const BARRIERS_POSITION = [\n      [7, 9],\n      [8, 9],\n      [9, 9],\n    ];\n\n    const squares = this.state.squares;\n\n    squares[START_ROW][START_COL] = {\n      id: { row: START_ROW, col: START_COL },\n      isStart: true,\n      isFinish: false,\n      isBarrier: false,\n    };\n\n    squares[FINISH_ROW][FINISH_COL] = {\n      id: { row: FINISH_ROW, col: FINISH_COL },\n      isStart: false,\n      isFinish: true,\n      isBarrier: false,\n    };\n\n    squares[FINISH_ROW][FINISH_COL] = {\n      id: { row: FINISH_ROW, col: FINISH_COL },\n      isStart: false,\n      isFinish: true,\n      isBarrier: false,\n    };\n\n    for (let i = 0; i < BARRIERS_POSITION.length; i++) {\n      let row = BARRIERS_POSITION[i][0];\n      let col = BARRIERS_POSITION[i][1];\n      squares[row][col] = {\n        id: { row: BARRIERS_POSITION[i][0], col: BARRIERS_POSITION[i][1] },\n        isStart: false,\n        isFinish: false,\n        isBarrier: true,\n      };\n    }\n\n    this.setState({ squares });\n  }\n\n  solve = (squares) => {\n    let visitedSquares = [];\n    this.setInfiniteDistanceFromStart(squares);\n    let start = this.getStartingSquare(squares);\n    let priorityQueue = [];\n    priorityQueue.push(start);\n    let isFinished = false;\n    while (priorityQueue.length && !isFinished) {\n      priorityQueue.sort((a, b) => {\n        if (a.distance <= b.distance) {\n          return -1;\n        }\n        return 1;\n      });\n      let currentSquare = priorityQueue[0];\n      //TODO: Remove?\n      priorityQueue.shift();\n      let neighbours = this.getNeighboursOf(currentSquare, squares);\n      for (let i = 0; i < neighbours.length; i++) {\n        let neighbour = neighbours[i];\n        let computedDistanceOfNeighbour = currentSquare.distance + 1;\n\n        if (computedDistanceOfNeighbour < neighbour.distance) {\n          neighbour.distance = computedDistanceOfNeighbour;\n          neighbour.previousSquare = currentSquare;\n        }\n\n        if (neighbour.isFinish) {\n          isFinished = true;\n          break;\n        }\n\n        if (!neighbour.hasBeenVisited) {\n          priorityQueue.push(neighbour);\n          neighbour.hasBeenVisited = true;\n          visitedSquares.push(neighbour);\n        }\n        squares[neighbour.id.row][neighbour.id.col] = neighbour;\n      }\n    }\n    //this.animateSolving(squaresForAnimation);\n    //TODO Not run when path can not be made\n    //this.animateShortestPath(this.getFinishSquare(squares), squares);\n    //this.setState({ wasSolved: true });\n    return visitedSquares;\n  };\n\n  solveWithHeuristics = (squares) => {\n    const POWER_OF_HEURISTICS = 4;\n    let visitedSquares = [];\n    this.setInfiniteDistanceFromStart(squares);\n    let start = this.getStartingSquare(squares);\n    let priorityQueue = [];\n    priorityQueue.push(start);\n    let isFinished = false;\n    while (priorityQueue.length && !isFinished) {\n      priorityQueue.sort((a, b) => {\n        if (a.distance <= b.distance) {\n          return -1;\n        }\n        return 1;\n      });\n      let currentSquare = priorityQueue[0];\n      //TODO: Remove exists?\n      priorityQueue.shift();\n      let neighbours = this.getNeighboursOf(currentSquare, squares);\n      for (let i = 0; i < neighbours.length; i++) {\n        let neighbour = neighbours[i];\n        let computedDistanceOfNeighbour = currentSquare.distance + 1;\n        let heuristics = this.getDistanceHeuristics(\n          neighbour,\n          squares,\n          POWER_OF_HEURISTICS\n        );\n        if (computedDistanceOfNeighbour + heuristics < neighbour.distance) {\n          neighbour.distance = computedDistanceOfNeighbour + heuristics;\n          neighbour.previousSquare = currentSquare;\n        }\n\n        if (neighbour.isFinish) {\n          isFinished = true;\n          break;\n        }\n\n        if (!neighbour.hasBeenVisited) {\n          priorityQueue.push(neighbour);\n          neighbour.hasBeenVisited = true;\n          visitedSquares.push(neighbour);\n        }\n        squares[neighbour.id.row][neighbour.id.col] = neighbour;\n      }\n    }\n    return visitedSquares;\n  };\n\n  getDistanceHeuristics = (square, squares, power) => {\n    let finishSquare = this.getFinishSquare(squares);\n    const squareRow = square.id.row;\n    const squareCol = square.id.col;\n    const finishRow = finishSquare.id.row;\n    const finishCol = finishSquare.id.col;\n    return Math.pow(\n      Math.abs(finishRow - squareRow) + Math.abs(finishCol - squareCol),\n      power\n    );\n  };\n\n  getNeighboursOf = (square, squares) => {\n    let squarePosition = square.id;\n    let neighbours = [];\n\n    //TODO: Refactor\n    if (squarePosition.row + 1 !== ROWS) {\n      if (!squares[squarePosition.row + 1][squarePosition.col].isBarrier) {\n        neighbours.push(squares[squarePosition.row + 1][squarePosition.col]);\n      }\n    }\n\n    if (squarePosition.col + 1 !== COLS) {\n      if (!squares[squarePosition.row][squarePosition.col + 1].isBarrier) {\n        neighbours.push(squares[squarePosition.row][squarePosition.col + 1]);\n      }\n    }\n\n    if (squarePosition.row - 1 >= 0) {\n      if (!squares[squarePosition.row - 1][squarePosition.col].isBarrier) {\n        neighbours.push(squares[squarePosition.row - 1][squarePosition.col]);\n      }\n    }\n\n    if (squarePosition.col - 1 >= 0) {\n      if (!squares[squarePosition.row][squarePosition.col - 1].isBarrier) {\n        neighbours.push(squares[squarePosition.row][squarePosition.col - 1]);\n      }\n    }\n\n    return neighbours;\n  };\n\n  setInfiniteDistanceFromStart = (squares) => {\n    for (let i = 0; i < COLS; i++) {\n      for (let j = 0; j < ROWS; j++) {\n        if (squares[i][j].isStart) {\n          squares[i][j][\"distance\"] = 0;\n        } else {\n          squares[i][j][\"distance\"] = Number.MAX_VALUE;\n        }\n        squares[i][j][\"previousSquare\"] = null;\n        squares[i][j][\"hasBeenVisited\"] = false;\n      }\n    }\n  };\n\n  getStartingSquare = (squares) => {\n    //TODO: Refactor\n    let startingSquare = {};\n    squares.filter((squaresInRow) => {\n      let squareRow = squaresInRow.filter((square) => {\n        if (square.isStart === true) {\n          startingSquare = square;\n        }\n      });\n    });\n    return startingSquare;\n  };\n\n  getFinishSquare = (squares) => {\n    //TODO: Refactor\n    let finishSquare = {};\n    squares.filter((squaresInRow) => {\n      let squareRow = squaresInRow.filter((square) => {\n        if (square.isFinish === true) {\n          finishSquare = square;\n        }\n      });\n    });\n    return finishSquare;\n  };\n\n  constructShortestPath = (startingSquare, finishSquare) => {\n    let shortestPath = [];\n    let tempSquare = finishSquare;\n    if (!finishSquare.previousSquare) {\n      return;\n    }\n    while (tempSquare !== startingSquare) {\n      shortestPath.push(tempSquare);\n      tempSquare = tempSquare.previousSquare;\n    }\n    shortestPath.reverse();\n    return shortestPath;\n  };\n\n  handleSolveClick = () => {\n    let squares = this.state.squares;\n    const startingSquare = this.getStartingSquare(squares);\n    const finishSquare = this.getFinishSquare(squares);\n    let visitedSquares = [];\n\n    if (this.state.algorithmType === \"dijkstra\") {\n      visitedSquares = this.solve(squares);\n    } else if (this.state.algorithmType == \"a_star\") {\n      visitedSquares = this.solveWithHeuristics(squares);\n    } else {\n      alert(\"NO algorithm has been chosen!\");\n      return;\n    }\n    this.animateSolving(squares, visitedSquares).then(() => {\n      const shortestPath = this.constructShortestPath(\n        startingSquare,\n        finishSquare\n      );\n\n      if (shortestPath) {\n        this.animateShortestPath(squares, shortestPath);\n      }\n    });\n  };\n\n  animateSolving = async (squares, visitedSquares) => {\n    const DELAY_BETWEEN_SQUARE_ANIMATION = 10;\n    return new Promise((resolve) => {\n      for (let i = 0; i < visitedSquares.length; i++) {\n        let currentSquare = visitedSquares[i];\n        setTimeout(() => {\n          squares[currentSquare.id.row][\n            currentSquare.id.col\n          ].isInSearchArea = true;\n          this.setState({ squares: squares });\n        }, DELAY_BETWEEN_SQUARE_ANIMATION * (i + 1));\n        setTimeout(\n          resolve,\n          DELAY_BETWEEN_SQUARE_ANIMATION * visitedSquares.length\n        );\n      }\n    });\n  };\n\n  animateShortestPath = (squares, shortestPath) => {\n    const DELAY_BETWEEN_SQUARE_ON_PATH_ANIMATION = 50;\n    for (let i = 0; i < shortestPath.length - 1; i++) {\n      setTimeout(() => {\n        let currentSquare = shortestPath[i];\n        //TODO: Timeout not working properly? Maybe problem with this.state.squares?\n        squares[currentSquare.id.row][\n          currentSquare.id.col\n        ].isOnShortestPath = true;\n        this.setState({ squares });\n      }, DELAY_BETWEEN_SQUARE_ON_PATH_ANIMATION * (i + 1));\n    }\n  };\n\n  eraseSearchAreaWithShortestPath = () => {\n    let squares = this.state.squares;\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLS; j++) {\n        squares[i][j].hasBeenVisited = false;\n        squares[i][j].isInSearchArea = false;\n        squares[i][j].isOnShortestPath = false;\n      }\n    }\n    this.setState({ squares: squares });\n  };\n\n  handleClickOnSquare = (idOfClickedSquare) => {\n    let squares = this.state.squares;\n    //TODO: ADD start node and finish node from start\n    const oldStartingSquare = this.getStartingSquare(squares);\n    const oldFinishSquare = this.getFinishSquare(squares);\n    //TODO: Proper refactoring needed\n    if (\n      idOfClickedSquare !== oldStartingSquare.id &&\n      idOfClickedSquare !== oldFinishSquare.id\n    ) {\n      if (this.state.selectedSquareType === \"start\") {\n        squares[oldStartingSquare.id.row][\n          oldStartingSquare.id.col\n        ].isStart = false;\n      }\n      if (this.state.selectedSquareType === \"finish\") {\n        squares[oldFinishSquare.id.row][\n          oldFinishSquare.id.col\n        ].isFinish = false;\n      }\n\n      squares[idOfClickedSquare.row][idOfClickedSquare.col] = {\n        ...squares[idOfClickedSquare.row][idOfClickedSquare.col],\n        id: { row: idOfClickedSquare.row, col: idOfClickedSquare.col },\n        isStart: this.state.selectedSquareType === \"start\" ? true : false,\n        isFinish: this.state.selectedSquareType === \"finish\" ? true : false,\n      };\n    }\n\n    if (this.state.selectedSquareType === \"barrier\") {\n      squares[idOfClickedSquare.row][\n        idOfClickedSquare.col\n      ].isBarrier = !squares[idOfClickedSquare.row][idOfClickedSquare.col]\n        .isBarrier;\n    }\n\n    this.setState({ squares: squares });\n    this.eraseSearchAreaWithShortestPath();\n  };\n\n  handleSquareTypeChoice = (event) => {\n    this.setState({ selectedSquareType: event.target.value });\n  };\n\n  handleAlgorithmChange = (event) => {\n    this.setState({ algorithmType: event.target.value });\n    this.eraseSearchAreaWithShortestPath();\n  };\n\n  render() {\n    const {\n      squares,\n      selectedSquareType,\n      wasSolved,\n      squaresForAnimation,\n      shortestPath,\n    } = this.state;\n    return (\n      <div className=\"App\">\n        <div className=\"navbar\">\n          <ul>\n            <li>Algo Visualizer</li>\n            <li>Shortest Path</li>\n          </ul>\n        </div>\n        <div className=\"solve-section\">\n          <div className=\"select-box\">\n            <label>Square: </label>\n            <select className=\"select\" onChange={this.handleSquareTypeChoice}>\n              <option value=\"start\">Start</option>\n              <option value=\"finish\">Finish</option>\n              <option value=\"barrier\">Barrier</option>\n            </select>\n          </div>\n          <div className=\"select-box\">\n            <label>Algorithm: </label>\n            <select className=\"select\" onChange={this.handleAlgorithmChange}>\n              <option value=\"dijkstra\">Dijkstra</option>\n              <option value=\"a_star\">A*</option>\n            </select>\n          </div>\n          <div>\n            <button className=\"solve-button\" onClick={this.handleSolveClick}>\n              Find shortest path\n            </button>\n          </div>\n        </div>\n        <div className=\"tablePosition\">\n          <Table\n            squares={squares}\n            selectedSquareType={selectedSquareType}\n            wasSolved={wasSolved}\n            squaresForAnimation={squaresForAnimation}\n            shortestPath={shortestPath}\n            setInSearchAreaPropertyOfSquare={\n              this.setInSearchAreaPropertyOfSquare\n            }\n            handleClickOnSquare={this.handleClickOnSquare}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default PathFinder;\n","import React from \"react\";\nimport PathFinder from \"./PathFinder\";\n\nclass App extends React.Component{\n\n  render() {\n    return(\n    <div>\n      <PathFinder></PathFinder>\n    </div>\n  );\n}\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}