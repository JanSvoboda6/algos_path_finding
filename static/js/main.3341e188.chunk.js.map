{"version":3,"sources":["Square.js","Table.js","algos/AlgosUtil.js","algos/AStar.js","PathFinder.js","algos/Dijkstra.js","App.js","serviceWorker.js","index.js"],"names":["Square","isStart","isFinish","isBarrier","isInSearchArea","hasMainStylingClass","isOnShortestPath","this","props","mainStylingClass","getMainStylingClass","searchAreaClass","getSearchAreaStylingClass","shortestPathClass","getOnShortestPathStylingClass","className","onClick","handleClickOnSquare","position","data-testid","React","Component","Table","squares","map","row","rowIndex","key","square","squareIndex","getNeighboursOf","squarePosition","neighbours","ROWS","length","COLS","isCurrentSquareOnBottomBorder","isCurrentSquareOnTopBorder","isCurrentSquareOnRightBorder","col","isCurrentSquareOnLeftBorder","push","setInfiniteDistanceFromStart","rows","cols","i","j","Number","MAX_VALUE","getDistanceHeuristics","finishSquare","power","squareRow","squareCol","finishRow","finishCol","Math","pow","abs","PathFinder","getStartingSquare","startingSquare","outerloop","getFinishSquare","animateSolving","visitedSquares","a","Promise","resolve","currentSquare","setTimeout","setState","animateShortestPath","shortestPath","eraseSearchAreaWithShortestPath","state","hasBeenVisited","previousSquare","handleSolveClick","algorithmType","priorityQueue","isFinished","sort","b","distance","closestSquare","shift","neighbour","distanceOfNeighbourFromStart","dijkstra","distanceOfNeighbourInheritedFromCurrentSquare","heuristics","aStar","alert","then","tempSquare","reverse","constructShortestPath","clickedSquarePosition","oldStartingSquare","oldFinishSquare","isClickedSquareStartingSquare","isClickedSquareFinishSquare","updatedSquare","selectedSquareType","isSquareBarrier","handleSquareTypeChoice","event","target","value","handleAlgorithmChange","wasSolved","createSquares","squaresInRow","createStartingTemplate","BARRIERS_POSITION","squaresForAnimation","onChange","setInSearchAreaPropertyOfSquare","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.3341e188.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./styles/Square.css\";\n\nclass Square extends React.Component {\n  \n  getMainStylingClass(isStart, isFinish, isBarrier) {\n    return isStart ? \"start\" : isFinish ? \"finish\" : isBarrier ? \"barrier\" : \"\";\n  }\n\n  getSearchAreaStylingClass(isInSearchArea, hasMainStylingClass) {\n    if (isInSearchArea && !hasMainStylingClass) {\n      return \"search-area\";\n    } else {\n      return \"\";\n    }\n  }\n\n  getOnShortestPathStylingClass(isOnShortestPath, hasMainStylingClass) {\n    if (isOnShortestPath && !hasMainStylingClass) {\n      return \"shortest-path\";\n    } else {\n      return \"\";\n    }\n  }\n\n  render() {\n    const { isStart, isFinish, isBarrier, isInSearchArea, isOnShortestPath } = this.props;\n\n    const mainStylingClass = this.getMainStylingClass(isStart, isFinish, isBarrier);\n\n    const hasMainStylingClass = mainStylingClass ? true : false;\n\n    const searchAreaClass = this.getSearchAreaStylingClass(isInSearchArea, hasMainStylingClass);\n\n    const shortestPathClass = this.getOnShortestPathStylingClass(isOnShortestPath, hasMainStylingClass);\n\n    return (\n      <button\n        className={`square ${mainStylingClass} ${searchAreaClass} ${shortestPathClass}`}\n        onClick={() => this.props.handleClickOnSquare(this.props.position)}\n        data-testid=\"square\"\n      ></button>\n    );\n  }\n}\n\nexport default Square;\n","import React from \"react\";\nimport Square from \"./Square\";\n\nclass Table extends React.Component {\n  render() {\n    const { squares } = this.props;\n    return (\n      <div>\n        {squares.map((row, rowIndex) => {\n          return (\n            <div key={rowIndex}>\n              {row.map((square, squareIndex) => {\n                return (\n                  <Square\n                    key={squareIndex}\n                    position={square.position}\n                    isStart={square.isStart}\n                    isFinish={square.isFinish}\n                    isBarrier={square.isBarrier}\n                    isInSearchArea={square.isInSearchArea}\n                    isOnShortestPath={square.isOnShortestPath}\n                    handleClickOnSquare={this.props.handleClickOnSquare}\n                  ></Square>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n}\n\nexport default Table;\n","export function getNeighboursOf(square, squares) {\n    let squarePosition = square.position;\n    let neighbours = [];\n  \n    const ROWS = squares.length;\n    const COLS = squares[0].length;\n  \n    const isCurrentSquareOnBottomBorder = squarePosition.row + 1 === ROWS ? true : false;\n    const isCurrentSquareOnTopBorder = squarePosition.row - 1 < 0 ? true : false;\n    const isCurrentSquareOnRightBorder = squarePosition.col + 1 === COLS ? true : false;\n    const isCurrentSquareOnLeftBorder = squarePosition.col - 1 < 0 ? true : false;\n\n    if (!isCurrentSquareOnBottomBorder) {\n      if (!squares[squarePosition.row + 1][squarePosition.col].isBarrier) {\n        neighbours.push(squares[squarePosition.row + 1][squarePosition.col]);\n      }\n    }\n  \n    if (!isCurrentSquareOnTopBorder) {\n      if (!squares[squarePosition.row - 1][squarePosition.col].isBarrier) {\n        neighbours.push(squares[squarePosition.row - 1][squarePosition.col]);\n      }\n    }\n  \n    if (!isCurrentSquareOnRightBorder) {\n      if (!squares[squarePosition.row][squarePosition.col + 1].isBarrier) {\n        neighbours.push(squares[squarePosition.row][squarePosition.col + 1]);\n      }\n    }\n  \n    if (!isCurrentSquareOnLeftBorder) {\n      if (!squares[squarePosition.row][squarePosition.col - 1].isBarrier) {\n        neighbours.push(squares[squarePosition.row][squarePosition.col - 1]);\n      }\n    }\n  \n    return neighbours;\n  }\n  \n  export function constructShortestPath(startingSquare, finishSquare) {\n    let shortestPath = [];\n    let tempSquare = finishSquare;\n\n    const isPossibleToConstructPath = finishSquare.previousSquare ? true : false;\n    if (!isPossibleToConstructPath) {\n      return;\n    }\n\n    while (tempSquare !== startingSquare) {\n      shortestPath.push(tempSquare);\n      tempSquare = tempSquare.previousSquare;\n    }  \n\n    shortestPath.push(startingSquare);\n    shortestPath.reverse();\n\n    return shortestPath;\n  }\n  \n  export function setInfiniteDistanceFromStart(squares){\n    const rows = squares.length;\n    const cols = squares[0].length;\n\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < cols; j++) {\n        if (squares[i][j].isStart) {\n          squares[i][j][\"distance\"] = 0;\n        } else {\n          squares[i][j][\"distance\"] = Number.MAX_VALUE;\n        }\n      }\n    }\n  };","import{setInfiniteDistanceFromStart, getNeighboursOf} from \"./AlgosUtil\";\n\nconst POWER_OF_HEURISTICS = 4;\n\nexport function aStar(squares, startingSquare, finishSquare) {\n  setInfiniteDistanceFromStart(squares);\n  let visitedSquares = [];\n  let priorityQueue = [];\n  let isFinished = false;\n  priorityQueue.push(startingSquare);\n\n  while (priorityQueue.length && !isFinished) {\n\n    priorityQueue.sort((a, b) => {\n      if (a.distance <= b.distance) {\n        return -1;\n      }\n      return 1;\n    });\n\n    let currentSquare = priorityQueue[0];\n    priorityQueue.shift();\n    let neighbours = getNeighboursOf(currentSquare, squares);\n\n    for (let i = 0; i < neighbours.length; i++) {\n      let neighbour = neighbours[i];\n      let distanceOfNeighbourInheritedFromCurrentSquare = currentSquare.distance + 1;\n      let heuristics = getDistanceHeuristics(neighbour, finishSquare, POWER_OF_HEURISTICS);\n\n      if (distanceOfNeighbourInheritedFromCurrentSquare + heuristics < neighbour.distance) {\n        neighbour.distance = distanceOfNeighbourInheritedFromCurrentSquare + heuristics;\n        neighbour.previousSquare = currentSquare;\n      }\n\n      if (neighbour === finishSquare) {\n        isFinished = true;\n        break;\n      }\n\n      if (!neighbour.hasBeenVisited) {\n        neighbour.hasBeenVisited = true;\n        priorityQueue.push(neighbour);\n        visitedSquares.push(neighbour);\n      }\n\n    }\n  }\n  return visitedSquares;\n}\n\nexport function getDistanceHeuristics (square, finishSquare, power){\n  const squareRow = square.position.row;\n  const squareCol = square.position.col;\n  const finishRow = finishSquare.position.row;\n  const finishCol = finishSquare.position.col;\n  return Math.pow(Math.abs(finishRow - squareRow) + Math.abs(finishCol - squareCol), power);\n};\n","import React from \"react\";\nimport \"./styles/PathFinder.css\";\nimport Table from \"./Table\";\nimport { dijkstra } from \"./algos/Dijkstra\";\nimport { aStar } from \"./algos/AStar\";\nimport { constructShortestPath } from \"./algos/AlgosUtil\";\n\nconst ROWS = 19;\nconst COLS = 19;\n\nclass PathFinder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      squares: [],\n      selectedSquareType: \"start\",\n      wasSolved: false,\n      visitedSquares: [],\n      shortestPath: [],\n      algorithmType: \"dijkstra\",\n    };\n  }\n\n  componentDidMount() {\n    this.createSquares();\n  }\n\n  createSquares() {\n    let squares = [];\n    for (let i = 0; i < ROWS; i++) {\n      let squaresInRow = [];\n      for (let j = 0; j < COLS; j++) {\n        const square = {\n          position: { row: i, col: j },\n          isStart: false,\n          isFinish: false,\n          isBarrier: false,\n        };\n        squaresInRow.push(square);\n      }\n      squares.push(squaresInRow);\n    }\n    this.setState({ squares }, this.createStartingTemplate);\n  }\n\n  createStartingTemplate() {\n    const squares = this.state.squares;\n    const START_ROW = 9;\n    const START_COL = 5;\n    const FINISH_ROW = 9;\n    const FINISH_COL = 13;\n    const BARRIERS_POSITION = [\n      [8, 9],\n      [9, 9],\n      [10, 9],\n    ];\n\n    squares[START_ROW][START_COL] = {\n      ...squares[START_ROW][START_COL],\n      position: { row: START_ROW, col: START_COL },\n      isStart: true,\n    };\n\n    squares[FINISH_ROW][FINISH_COL] = {\n      ...squares[FINISH_ROW][FINISH_COL],\n      position: { row: FINISH_ROW, col: FINISH_COL },\n      isFinish: true,\n    };\n\n    for (let i = 0; i < BARRIERS_POSITION.length; i++) {\n      let row = BARRIERS_POSITION[i][0];\n      let col = BARRIERS_POSITION[i][1];\n      squares[row][col] = {\n        ...squares[BARRIERS_POSITION[i][0]][BARRIERS_POSITION[i][1]],\n        isBarrier: true,\n      };\n    }\n\n    this.setState({ squares });\n  }\n\n  getStartingSquare = (squares) => {\n    let startingSquare = {};\n    outerloop: for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLS; j++) {\n        if (squares[i][j].isStart) {\n          startingSquare = squares[i][j];\n          break outerloop;\n        }\n      }\n    }\n    return startingSquare;\n  };\n\n  getFinishSquare = (squares) => {\n    let finishSquare = {};\n    outerloop: for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLS; j++) {\n        if (squares[i][j].isFinish) {\n          finishSquare = squares[i][j];\n          break outerloop;\n        }\n      }\n    }\n    return finishSquare;\n  };\n\n  animateSolving = async (squares, visitedSquares) => {\n    const DELAY_BETWEEN_SQUARE_ANIMATION = 10;\n    return new Promise((resolve) => {\n      for (let i = 0; i < visitedSquares.length; i++) {\n        let currentSquare = visitedSquares[i];\n        setTimeout(() => {\n          squares[currentSquare.position.row][currentSquare.position.col].isInSearchArea = true;\n          this.setState({ squares: squares });\n        }, DELAY_BETWEEN_SQUARE_ANIMATION * (i + 1));\n        setTimeout(resolve, DELAY_BETWEEN_SQUARE_ANIMATION * visitedSquares.length);\n      }\n    });\n  };\n\n  animateShortestPath = (squares, shortestPath) => {\n    const DELAY_BETWEEN_SQUARE_ON_PATH_ANIMATION = 50;\n    for (let i = 0; i < shortestPath.length - 1; i++) {\n      setTimeout(() => {\n        let currentSquare = shortestPath[i];\n        squares[currentSquare.position.row][currentSquare.position.col].isOnShortestPath = true;\n        this.setState({ squares });\n      }, DELAY_BETWEEN_SQUARE_ON_PATH_ANIMATION * (i + 1));\n    }\n  };\n\n  eraseSearchAreaWithShortestPath = () => {\n    let squares = this.state.squares;\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLS; j++) {\n        squares[i][j].hasBeenVisited = false;\n        squares[i][j].isInSearchArea = false;\n        squares[i][j].isOnShortestPath = false;\n        squares[i][j].previousSquare = null;\n      }\n    }\n    this.setState({ squares: squares });\n  };\n\n  handleSolveClick = () => {\n    this.eraseSearchAreaWithShortestPath();\n    let squares = this.state.squares;\n    let visitedSquares = [];\n    const startingSquare = this.getStartingSquare(squares);\n    const finishSquare = this.getFinishSquare(squares);\n\n    switch (this.state.algorithmType) {\n      case \"dijkstra\":\n        visitedSquares = dijkstra(squares, startingSquare, finishSquare);\n        break;\n      case \"a_star\":\n        visitedSquares = aStar(squares, startingSquare, finishSquare);\n        break;\n      default:\n        alert(\"No algorithm has been chosen!\");\n        return;\n    }\n\n    this.animateSolving(squares, visitedSquares).then(() => {\n      const shortestPath = constructShortestPath(startingSquare, finishSquare);\n      if (shortestPath) {\n        this.animateShortestPath(squares, shortestPath);\n      }\n    });\n  };\n\n  handleClickOnSquare = (clickedSquarePosition) => {\n    this.eraseSearchAreaWithShortestPath();\n    let squares = this.state.squares;\n    const oldStartingSquare = this.getStartingSquare(squares);\n    const oldFinishSquare = this.getFinishSquare(squares);\n\n    const isClickedSquareStartingSquare = clickedSquarePosition === oldStartingSquare.position;\n    const isClickedSquareFinishSquare = clickedSquarePosition === oldFinishSquare.position;\n\n    if (isClickedSquareStartingSquare || isClickedSquareFinishSquare) {\n      return;\n    }\n\n    let updatedSquare = squares[clickedSquarePosition.row][clickedSquarePosition.col];\n\n    switch (this.state.selectedSquareType) {\n      case \"start\":\n        squares[oldStartingSquare.position.row][oldStartingSquare.position.col].isStart = false;\n        updatedSquare.isStart = true;\n        updatedSquare.isBarrier = false;\n        break;\n      case \"finish\":\n        squares[oldFinishSquare.position.row][oldFinishSquare.position.col].isFinish = false;\n        updatedSquare.isFinish = true;\n        updatedSquare.isBarrier = false;\n        break;\n      case \"barrier\":\n        let isSquareBarrier = squares[clickedSquarePosition.row][clickedSquarePosition.col].isBarrier;\n        updatedSquare.isBarrier = !isSquareBarrier;\n        break;\n      default:\n        return;\n    }\n\n    this.setState({ squares: squares });\n  };\n\n  handleSquareTypeChoice = (event) => {\n    this.setState({ selectedSquareType: event.target.value });\n  };\n\n  handleAlgorithmChange = (event) => {\n    this.setState({ algorithmType: event.target.value });\n    this.eraseSearchAreaWithShortestPath();\n  };\n\n  render() {\n    const { squares, selectedSquareType, wasSolved, squaresForAnimation, shortestPath } = this.state;\n    return (\n      <div className=\"path-finder\">\n        <div className=\"navbar\">\n          <ul>\n            <li>Algo Visualizer</li>\n            <li>Shortest Path</li>\n          </ul>\n        </div>\n        <div className=\"solve-section\">\n          <div className=\"select-box\">\n            <label>Square: </label>\n            <select className=\"select\" onChange={this.handleSquareTypeChoice}>\n              <option value=\"start\">Start</option>\n              <option value=\"finish\">Finish</option>\n              <option value=\"barrier\">Barrier</option>\n            </select>\n          </div>\n          <div className=\"select-box\">\n            <label>Algorithm: </label>\n            <select className=\"select\" onChange={this.handleAlgorithmChange}>\n              <option value=\"dijkstra\">Dijkstra</option>\n              <option value=\"a_star\">A*</option>\n            </select>\n          </div>\n          <div>\n            <button className=\"solve-button\" onClick={this.handleSolveClick}>\n              Find shortest path\n            </button>\n          </div>\n        </div>\n        <div className=\"tablePosition\">\n          <Table\n            squares={squares}\n            selectedSquareType={selectedSquareType}\n            wasSolved={wasSolved}\n            squaresForAnimation={squaresForAnimation}\n            shortestPath={shortestPath}\n            setInSearchAreaPropertyOfSquare={this.setInSearchAreaPropertyOfSquare}\n            handleClickOnSquare={this.handleClickOnSquare}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default PathFinder;\n","import { setInfiniteDistanceFromStart, getNeighboursOf } from \"./AlgosUtil\";\n\nexport function dijkstra(squares, startingSquare, finishSquare) {\n  let visitedSquares = [];\n  let priorityQueue = [];\n  let isFinished = false;\n  setInfiniteDistanceFromStart(squares);\n  priorityQueue.push(startingSquare);\n  while (priorityQueue.length && !isFinished) {\n\n    priorityQueue.sort((a, b) => {\n      if (a.distance <= b.distance) {\n        return -1;\n      }\n      return 1;\n    });\n\n    let closestSquare = priorityQueue[0];\n    priorityQueue.shift();\n    let neighbours = getNeighboursOf(closestSquare, squares);\n\n    for (let i = 0; i < neighbours.length; i++) {\n      let neighbour = neighbours[i];\n      let distanceOfNeighbourFromStart = closestSquare.distance + 1;\n\n      if (distanceOfNeighbourFromStart < neighbour.distance) {\n        neighbour.distance = distanceOfNeighbourFromStart;\n        neighbour.previousSquare = closestSquare;\n      }\n\n      if (neighbour === finishSquare) {\n        isFinished = true;\n        break;\n      }\n\n      if (!neighbour.hasBeenVisited) {\n        neighbour.hasBeenVisited = true;\n        priorityQueue.push(neighbour);\n        visitedSquares.push(neighbour);\n      }\n    }\n  }\n  return visitedSquares;\n}\n","import React from \"react\";\nimport PathFinder from \"./PathFinder\";\n\nclass App extends React.Component{\n\n  render() {\n    return(\n    <div>\n      <PathFinder></PathFinder>\n    </div>\n  );\n}\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}