{"version":3,"sources":["Square.js","Table.js","PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["Square","props","state","this","isStart","isFinish","isBarrier","isInSearchArea","btnClass","searchAreaClass","isOnShortestPathClass","isOnShortestPath","className","onClick","handleClickOnSquare","id","React","Component","Table","squares","map","row","rowIndex","key","square","squareIndex","PathFinder","solve","visitedSquares","setInfiniteDistanceFromStart","start","getStartingSquare","priorityQueue","push","isFinished","length","sort","a","b","distance","currentSquare","shift","neighbours","getNeighboursOf","i","neighbour","computedDistanceOfNeighbour","previousSquare","hasBeenVisited","col","squarePosition","j","startingSquare","filter","squaresInRow","getFinishSquare","finishSquare","constructShortestPath","shortestPath","tempSquare","reverse","handleSolveClick","animateSolving","then","animateShortestPath","handleSquareTypeChoice","event","setState","selectedSquareType","target","value","Promise","resolve","setTimeout","eraseSearchAreaWithShortestPath","idOfClickedSquare","oldStartingSquare","oldFinishSquare","wasSolved","createSquares","chooseSquares","BARRIERS_POSITION","squaresForAnimation","onChange","setInSearchAreaPropertyOfSquare","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"2VA6CeA,G,8DAzCb,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,GAFI,E,qDAST,IAAD,SACoEC,KAAKF,MAAxEG,EADD,EACCA,QAASC,EADV,EACUA,SAAUC,EADpB,EACoBA,UAAWC,EAD/B,EAC+BA,eAElCC,EAAWJ,EACX,QACAC,EACA,SACAC,EACA,UACA,GAEAG,EAAkB,GAEL,KAAbD,IACFC,EAAkBF,EAAiB,cAAgB,IAGrD,IAAIG,EAAwB,GAK5B,OAtBO,EAC+CC,mBAkBpDD,EAAwB,gBAIxB,4BACEE,UAAS,iBAAYJ,EAAZ,YAAwBC,EAAxB,YAA2CC,GACpDG,QAAS,kBAAM,EAAKZ,MAAMa,oBAAoB,EAAKb,MAAMc,W,GAnC5CC,IAAMC,YCsCZC,E,kDApCb,WAAYjB,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,CAAEiB,QAAS,IAFP,E,qDAKT,IAAD,OACCA,EAAYhB,KAAKF,MAAjBkB,QACR,OACE,6BACE,yBAAKP,UAAU,SACZO,EAAQC,KAAI,SAACC,EAAKC,GACjB,OACE,yBAAKC,IAAKD,GACPD,EAAID,KAAI,SAACI,EAAQC,GAChB,OACE,kBAAC,EAAD,CACEF,IAAKE,EACLV,GAAIS,EAAOT,GACXX,QAASoB,EAAOpB,QAChBC,SAAUmB,EAAOnB,SACjBC,UAAWkB,EAAOlB,UAClBC,eAAgBiB,EAAOjB,eACvBI,iBAAkBa,EAAOb,iBACzBG,oBAAqB,EAAKb,MAAMa,mC,GAxBlCE,IAAMC,WCmXXS,E,kDA/Wb,WAAYzB,GAAQ,IAAD,8BACjB,cAAMA,IAgFR0B,MAAQ,SAACR,GACP,IAAIS,EAAiB,GACrB,EAAKC,6BAA6BV,GAClC,IAAIW,EAAQ,EAAKC,kBAAkBZ,GAC/Ba,EAAgB,GACpBA,EAAcC,KAAKH,GAEnB,IADA,IAAII,GAAa,EACVF,EAAcG,SAAWD,GAAY,CAC1CF,EAAcI,MAAK,SAACC,EAAGC,GACrB,OAAID,EAAEE,UAAYD,EAAEC,UACV,EAEH,KAET,IAAIC,EAAgBR,EAAc,GAElCA,EAAcS,QAEd,IADA,IAAIC,EAAa,EAAKC,gBAAgBH,EAAerB,GAC5CyB,EAAI,EAAGA,EAAIF,EAAWP,OAAQS,IAAK,CAC1C,IAAIC,EAAYH,EAAWE,GACvBE,EAA8BN,EAAcD,SAAW,EAO3D,GALIO,EAA8BD,EAAUN,WAC1CM,EAAUN,SAAWO,EACrBD,EAAUE,eAAiBP,GAGzBK,EAAUxC,SAAU,CACtB6B,GAAa,EACb,MAGGW,EAAUG,iBACbhB,EAAcC,KAAKY,GACnBA,EAAUG,gBAAiB,EAC3BpB,EAAeK,KAAKY,IAEtB1B,EAAQ0B,EAAU9B,GAAGM,KAAKwB,EAAU9B,GAAGkC,KAAOJ,GAOlD,OAAOjB,GA7HU,EAgInBe,gBAAkB,SAACnB,EAAQL,GACzB,IAAI+B,EAAiB1B,EAAOT,GACxB2B,EAAa,GA2BjB,OAxBIQ,EAAe7B,IAAM,IAxIhB,KAyIFF,EAAQ+B,EAAe7B,IAAM,GAAG6B,EAAeD,KAAK3C,WACvDoC,EAAWT,KAAKd,EAAQ+B,EAAe7B,IAAM,GAAG6B,EAAeD,OAI/DC,EAAeD,IAAM,IA/IhB,KAgJF9B,EAAQ+B,EAAe7B,KAAK6B,EAAeD,IAAM,GAAG3C,WACvDoC,EAAWT,KAAKd,EAAQ+B,EAAe7B,KAAK6B,EAAeD,IAAM,KAIjEC,EAAe7B,IAAM,GAAK,IACvBF,EAAQ+B,EAAe7B,IAAM,GAAG6B,EAAeD,KAAK3C,WACvDoC,EAAWT,KAAKd,EAAQ+B,EAAe7B,IAAM,GAAG6B,EAAeD,OAI/DC,EAAeD,IAAM,GAAK,IACvB9B,EAAQ+B,EAAe7B,KAAK6B,EAAeD,IAAM,GAAG3C,WACvDoC,EAAWT,KAAKd,EAAQ+B,EAAe7B,KAAK6B,EAAeD,IAAM,KAI9DP,GA7JU,EAgKnBb,6BAA+B,SAACV,GAC9B,IAAK,IAAIyB,EAAI,EAAGA,EArKP,GAqKiBA,IACxB,IAAK,IAAIO,EAAI,EAAGA,EArKT,GAqKmBA,IACpBhC,EAAQyB,GAAGO,GAAG/C,QAChBe,EAAQyB,GAAGO,GAAX,SAA4B,EAE5BhC,EAAQyB,GAAGO,GAAX,SAA4B,IAE9BhC,EAAQyB,GAAGO,GAAX,eAAkC,KAClChC,EAAQyB,GAAGO,GAAX,gBAAkC,GAzKrB,EA8KnBpB,kBAAoB,SAACZ,GAEnB,IAAIiC,EAAiB,GAQrB,OAPAjC,EAAQkC,QAAO,SAACC,GACEA,EAAaD,QAAO,SAAC7B,IACZ,IAAnBA,EAAOpB,UACTgD,EAAiB5B,SAIhB4B,GAxLU,EA2LnBG,gBAAkB,SAACpC,GAEjB,IAAIqC,EAAe,GAQnB,OAPArC,EAAQkC,QAAO,SAACC,GACEA,EAAaD,QAAO,SAAC7B,IACX,IAApBA,EAAOnB,WACTmD,EAAehC,SAIdgC,GArMU,EAwMnBC,sBAAwB,SAACL,EAAgBI,GACvC,IAAIE,EAAe,GACfC,EAAaH,EACjB,GAAIA,EAAaT,eAAjB,CAGA,KAAOY,IAAeP,GACpBM,EAAazB,KAAK0B,GAClBA,EAAaA,EAAWZ,eAG1B,OADAW,EAAaE,UACNF,IAnNU,EAsNnBG,iBAAmB,WACjB,IAAI1C,EAAU,EAAKjB,MAAMiB,QACnBiC,EAAiB,EAAKrB,kBAAkBZ,GACxCqC,EAAe,EAAKD,gBAAgBpC,GACpCS,EAAiB,EAAKD,MAAMR,GAClC,EAAK2C,eAAe3C,EAASS,GAAgBmC,MAAK,WAChD,IAAML,EAAe,EAAKD,sBACxBL,EACAI,GAGCE,GACD,EAAKM,oBAAoB7C,EAASuC,OAlOrB,EAwOnBO,uBAAyB,SAACC,GACxB,EAAKC,SAAS,CAAEC,mBAAoBF,EAAMG,OAAOC,SAzOhC,EA4OnBR,eA5OmB,uCA4OF,WAAO3C,EAASS,GAAhB,SAAAS,EAAA,6DACwB,EADxB,kBAER,IAAIkC,SAAQ,SAACC,GAClB,IAD+B,IAAD,WACrB5B,GACP,IAAIJ,EAAgBZ,EAAegB,GACnC6B,YAAW,WACTtD,EAAQqB,EAAczB,GAAGM,KACvBmB,EAAczB,GAAGkC,KACjB1C,gBAAiB,EACnB,EAAK4D,SAAS,CAAEhD,QAASA,MARQ,GASEyB,EAAI,IACzC6B,WACED,EAXiC,EAYA5C,EAAeO,SAV3CS,EAAI,EAAGA,EAAIhB,EAAeO,OAAQS,IAAM,EAAxCA,OAHI,2CA5OE,0DA+PnBoB,oBAAsB,SAAC7C,EAASuC,GAE9B,IADA,IAD+C,WAEtCd,GACP6B,YAAW,WACT,IAAIjC,EAAgBkB,EAAad,GAEjCzB,EAAQqB,EAAczB,GAAGM,KACvBmB,EAAczB,GAAGkC,KACjBtC,kBAAmB,EACrB,EAAKwD,SAAS,CAAEhD,cAR2B,KASAyB,EAAI,KAR1CA,EAAI,EAAGA,EAAIc,EAAavB,OAAS,EAAGS,IAAM,EAA1CA,IAjQQ,EA6QnB8B,gCAAkC,WAEhC,IADA,IAAIvD,EAAU,EAAKjB,MAAMiB,QAChByB,EAAI,EAAGA,EAlRP,GAkRiBA,IACxB,IAAK,IAAIO,EAAI,EAAGA,EApRT,GAoRmBA,IACxBhC,EAAQyB,GAAGO,GAAGH,gBAAiB,EAC/B7B,EAAQyB,GAAGO,GAAG5C,gBAAiB,EAC/BY,EAAQyB,GAAGO,GAAGxC,kBAAmB,EAGrC,EAAKwD,SAAS,CAAEhD,QAASA,KAtRR,EAyRnBL,oBAAsB,SAAC6D,GACrB,IAAIxD,EAAU,EAAKjB,MAAMiB,QAEnByD,EAAoB,EAAK7C,kBAAkBZ,GAC3C0D,EAAkB,EAAKtB,gBAAgBpC,GAG3CwD,IAAsBC,EAAkB7D,IACxC4D,IAAsBE,EAAgB9D,KAEA,UAAlC,EAAKb,MAAMkE,qBACbjD,EAAQyD,EAAkB7D,GAAGM,KAC3BuD,EAAkB7D,GAAGkC,KACrB7C,SAAU,GAEwB,WAAlC,EAAKF,MAAMkE,qBACbjD,EAAQ0D,EAAgB9D,GAAGM,KACzBwD,EAAgB9D,GAAGkC,KACnB5C,UAAW,GAGfc,EAAQwD,EAAkBtD,KAAKsD,EAAkB1B,KAAjD,2BACM9B,EAAQwD,EAAkBtD,KAAKsD,EAAkB1B,MADvD,IAEElC,GAAI,CAAEM,IAAKsD,EAAkBtD,IAAK4B,IAAK0B,EAAkB1B,KACzD7C,QAA2C,UAAlC,EAAKF,MAAMkE,mBACpB/D,SAA4C,WAAlC,EAAKH,MAAMkE,sBAIa,YAAlC,EAAKlE,MAAMkE,qBACbjD,EAAQwD,EAAkBtD,KAAKsD,EAAkB1B,KAAK3C,WAAaa,EAAQwD,EAAkBtD,KAAKsD,EAAkB1B,KAAK3C,WAG3H,EAAK6D,SAAS,CAAEhD,QAASA,IACzB,EAAKuD,mCAzTL,EAAKxE,MAAQ,CACXiB,QAAS,GACTiD,mBAAoB,QACpBU,WAAW,EACXlD,eAAgB,GAChB8B,aAAc,IAPC,E,gEAYjBvD,KAAK4E,kB,sCAKL,IADA,IAAI5D,EAAU,GACLyB,EAAI,EAAGA,EArBP,GAqBiBA,IAAK,CAE7B,IADA,IAAIU,EAAe,GACVH,EAAI,EAAGA,EAtBT,GAsBmBA,IAAK,CAC7B,IAAM3B,EAAS,CACbT,GAAI,CAAEM,IAAKuB,EAAGK,IAAKE,GACnB/C,SAAS,EACTC,UAAU,EACVC,WAAW,GAGbgD,EAAarB,KAAKT,GAEpBL,EAAQc,KAAKqB,GAEfnD,KAAKgE,SAAS,CAAEhD,WAAWhB,KAAK6E,iB,sCAIhC,IAMMC,EAAoB,CAAC,CAAC,EAAE,GAAI,CAAC,EAAE,GAAI,CAAC,EAAE,IAEtC9D,EAAUhB,KAAKD,MAAMiB,QAE3BA,EAVkB,GACA,GASc,CAC9BJ,GAAI,CAAEM,IAXU,EAWM4B,IAVN,GAWhB7C,SAAS,EACTC,UAAU,EACVC,WAAW,GAGba,EAdmB,GACA,IAae,CAChCJ,GAAI,CAAEM,IAfW,EAeM4B,IAdN,IAejB7C,SAAS,EACTC,UAAU,EACVC,WAAW,GAGba,EArBmB,GACA,IAoBe,CAChCJ,GAAI,CAAEM,IAtBW,EAsBM4B,IArBN,IAsBjB7C,SAAS,EACTC,UAAU,EACVC,WAAW,GAGb,IAAI,IAAIsC,EAAI,EAAGA,EAAIqC,EAAkB9C,OAAQS,IAC7C,CACE,IAAIvB,EAAM4D,EAAkBrC,GAAG,GAC3BK,EAAMgC,EAAkBrC,GAAG,GAC/BzB,EAAQE,GAAK4B,GAAO,CAClBlC,GAAI,CAAEM,IAAK4D,EAAkBrC,GAAG,GAAIK,IAAKgC,EAAkBrC,GAAG,IAC9DxC,SAAS,EACTC,UAAU,EACVC,WAAW,GAIfH,KAAKgE,SAAS,CAAEhD,c,+BAgPR,IAAD,EAOHhB,KAAKD,MALPiB,EAFK,EAELA,QACAiD,EAHK,EAGLA,mBACAU,EAJK,EAILA,UACAI,EALK,EAKLA,oBACAxB,EANK,EAMLA,aAEF,OACE,yBAAK9C,UAAU,OACb,yBAAKA,UAAU,UACb,4BACE,+CACA,+CAGJ,yBAAKA,UAAU,iBACb,yBAAKA,UAAU,cACb,kDACA,4BAAQA,UAAU,SAASuE,SAAUhF,KAAK8D,wBACxC,4BAAQK,MAAM,SAAd,SACA,4BAAQA,MAAM,UAAd,UACA,4BAAQA,MAAM,WAAd,aAGJ,6BACA,4BAAQ1D,UAAU,eAAeC,QAASV,KAAK0D,kBAA/C,wBAKF,yBAAKjD,UAAU,iBACb,kBAAC,EAAD,CACEO,QAASA,EACTiD,mBAAoBA,EACpBU,UAAWA,EACXI,oBAAqBA,EACrBxB,aAAcA,EACd0B,gCACEjF,KAAKiF,gCAEPtE,oBAAqBX,KAAKW,4B,GAxWbE,IAAMC,WCUhBoE,E,uKARX,OACA,6BACE,kBAAC,EAAD,W,GALYrE,IAAMC,WCMJqE,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBnC,MAAK,SAAAoC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.83c4a694.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./Square.css\";\n\nclass Square extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  // handleMouseDown = () => {\n  //   console.log(\"working\");\n  // }\n\n  render() {\n    const { isStart, isFinish, isBarrier, isInSearchArea, isOnShortestPath } = this.props;\n\n    let btnClass = isStart\n      ? \"start\"\n      : isFinish\n      ? \"finish\"\n      : isBarrier\n      ? \"barrier\"\n      : \"\";\n\n    let searchAreaClass = \"\";\n    //TODO: Refactor\n    if (btnClass === \"\") {\n      searchAreaClass = isInSearchArea ? \"search-area\" : \"\";\n    }\n\n    let isOnShortestPathClass = \"\"; \n    if(isOnShortestPath){\n      isOnShortestPathClass = \"shortestPath\";\n    }\n\n    return (\n      <button\n        className={`square ${btnClass} ${searchAreaClass} ${isOnShortestPathClass}`}\n        onClick={() => this.props.handleClickOnSquare(this.props.id)}\n        //onMouseDown={ () => this.handleMouseDown()}\n      ></button>\n    );\n  }\n}\n\nexport default Square;\n","import React from \"react\";\nimport Square from \"./Square\";\n\n\nclass Table extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { squares: [] };\n  }\n\n  render() {\n    const { squares } = this.props;\n    return (\n      <div>\n        <div className=\"table\">\n          {squares.map((row, rowIndex) => {\n            return (\n              <div key={rowIndex}>\n                {row.map((square, squareIndex) => {\n                  return (\n                    <Square\n                      key={squareIndex}\n                      id={square.id}\n                      isStart={square.isStart}\n                      isFinish={square.isFinish}\n                      isBarrier={square.isBarrier}\n                      isInSearchArea={square.isInSearchArea}\n                      isOnShortestPath={square.isOnShortestPath}\n                      handleClickOnSquare={this.props.handleClickOnSquare}\n                    ></Square>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>  \n      </div>\n    );\n  }\n}\n\nexport default Table;\n","import React from \"react\";\nimport \"./PathFinder.css\";\nimport Table from \"./Table\";\n\nconst COLS = 19;\nconst ROWS = 19;\n\nclass PathFinder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      squares: [],\n      selectedSquareType: \"start\",\n      wasSolved: false,\n      visitedSquares: [],\n      shortestPath: [],\n    };\n  }\n\n  componentDidMount() {\n    this.createSquares();\n  }\n\n  createSquares() {\n    let squares = [];\n    for (let i = 0; i < COLS; i++) {\n      let squaresInRow = [];\n      for (let j = 0; j < ROWS; j++) {\n        const square = {\n          id: { row: i, col: j },\n          isStart: false,\n          isFinish: false,\n          isBarrier: false,\n          //isInSearchArea: false,\n        };\n        squaresInRow.push(square);\n      }\n      squares.push(squaresInRow);\n    }\n    this.setState({ squares }, this.chooseSquares);\n  }\n\n  chooseSquares() {\n    const START_ROW = 8;\n    const START_COL = 5;\n\n    const FINISH_ROW = 8;\n    const FINISH_COL = 13;\n\n    const BARRIERS_POSITION = [[7,9], [8,9], [9,9]];\n\n    const squares = this.state.squares;\n\n    squares[START_ROW][START_COL] = {\n      id: { row: START_ROW, col: START_COL },\n      isStart: true,\n      isFinish: false,\n      isBarrier: false,\n    };\n\n    squares[FINISH_ROW][FINISH_COL] = {\n      id: { row: FINISH_ROW, col: FINISH_COL },\n      isStart: false,\n      isFinish: true,\n      isBarrier: false,\n    };\n\n    squares[FINISH_ROW][FINISH_COL] = {\n      id: { row: FINISH_ROW, col: FINISH_COL },\n      isStart: false,\n      isFinish: true,\n      isBarrier: false,\n    };\n\n    for(let i = 0; i < BARRIERS_POSITION.length; i ++)\n    {\n      let row = BARRIERS_POSITION[i][0];\n      let col = BARRIERS_POSITION[i][1];\n      squares[row][col] = {\n        id: { row: BARRIERS_POSITION[i][0], col: BARRIERS_POSITION[i][1]},\n        isStart: false,\n        isFinish: false,\n        isBarrier: true,\n      };\n    };\n\n    this.setState({ squares });\n  }\n\n  solve = (squares) => {\n    let visitedSquares = [];\n    this.setInfiniteDistanceFromStart(squares);\n    let start = this.getStartingSquare(squares);\n    let priorityQueue = [];\n    priorityQueue.push(start);\n    let isFinished = false;\n    while (priorityQueue.length && !isFinished) {\n      priorityQueue.sort((a, b) => {\n        if (a.distance <= b.distance) {\n          return -1;\n        }\n        return 1;\n      });\n      let currentSquare = priorityQueue[0];\n      //TODO: Remove?\n      priorityQueue.shift();\n      let neighbours = this.getNeighboursOf(currentSquare, squares);\n      for (let i = 0; i < neighbours.length; i++) {\n        let neighbour = neighbours[i];\n        let computedDistanceOfNeighbour = currentSquare.distance + 1;\n\n        if (computedDistanceOfNeighbour < neighbour.distance) {\n          neighbour.distance = computedDistanceOfNeighbour;\n          neighbour.previousSquare = currentSquare;\n        }\n\n        if (neighbour.isFinish) {\n          isFinished = true;\n          break;\n        }\n\n        if (!neighbour.hasBeenVisited) {\n          priorityQueue.push(neighbour);\n          neighbour.hasBeenVisited = true;\n          visitedSquares.push(neighbour);\n        }\n        squares[neighbour.id.row][neighbour.id.col] = neighbour;\n      }\n    }\n    //this.animateSolving(squaresForAnimation);\n    //TODO Not run when path can not be made\n    //this.animateShortestPath(this.getFinishSquare(squares), squares);\n    //this.setState({ wasSolved: true });\n    return visitedSquares;\n  };\n\n  getNeighboursOf = (square, squares) => {\n    let squarePosition = square.id;\n    let neighbours = [];\n\n    //TODO: Refactor\n    if (squarePosition.row + 1 !== ROWS) {\n      if (!squares[squarePosition.row + 1][squarePosition.col].isBarrier) {\n        neighbours.push(squares[squarePosition.row + 1][squarePosition.col]);\n      }\n    }\n\n    if (squarePosition.col + 1 !== COLS) {\n      if (!squares[squarePosition.row][squarePosition.col + 1].isBarrier) {\n        neighbours.push(squares[squarePosition.row][squarePosition.col + 1]);\n      }\n    }\n\n    if (squarePosition.row - 1 >= 0) {\n      if (!squares[squarePosition.row - 1][squarePosition.col].isBarrier) {\n        neighbours.push(squares[squarePosition.row - 1][squarePosition.col]);\n      }\n    }\n\n    if (squarePosition.col - 1 >= 0) {\n      if (!squares[squarePosition.row][squarePosition.col - 1].isBarrier) {\n        neighbours.push(squares[squarePosition.row][squarePosition.col - 1]);\n      }\n    }\n\n    return neighbours;\n  };\n\n  setInfiniteDistanceFromStart = (squares) => {\n    for (let i = 0; i < COLS; i++) {\n      for (let j = 0; j < ROWS; j++) {\n        if (squares[i][j].isStart) {\n          squares[i][j][\"distance\"] = 0;\n        } else {\n          squares[i][j][\"distance\"] = 999;\n        }\n        squares[i][j][\"previousSquare\"] = null;\n        squares[i][j][\"hasBeenVisited\"] = false;\n      }\n    }\n  };\n\n  getStartingSquare = (squares) => {\n    //TODO: Refactor\n    let startingSquare = {};\n    squares.filter((squaresInRow) => {\n      let squareRow = squaresInRow.filter((square) => {\n        if (square.isStart === true) {\n          startingSquare = square;\n        }\n      });\n    });\n    return startingSquare;\n  };\n\n  getFinishSquare = (squares) => {\n    //TODO: Refactor\n    let finishSquare = {};\n    squares.filter((squaresInRow) => {\n      let squareRow = squaresInRow.filter((square) => {\n        if (square.isFinish === true) {\n          finishSquare = square;\n        }\n      });\n    });\n    return finishSquare;\n  };\n\n  constructShortestPath = (startingSquare, finishSquare) => {\n    let shortestPath = [];\n    let tempSquare = finishSquare;\n    if(!finishSquare.previousSquare){\n      return;\n    }\n    while (tempSquare !== startingSquare) {\n      shortestPath.push(tempSquare);\n      tempSquare = tempSquare.previousSquare;\n    }\n    shortestPath.reverse();\n    return shortestPath;\n  };\n\n  handleSolveClick = () => {\n    let squares = this.state.squares;\n    const startingSquare = this.getStartingSquare(squares);\n    const finishSquare = this.getFinishSquare(squares);\n    const visitedSquares = this.solve(squares);\n    this.animateSolving(squares, visitedSquares).then(() => {\n      const shortestPath = this.constructShortestPath(\n        startingSquare,\n        finishSquare\n      );\n\n      if(shortestPath){\n        this.animateShortestPath(squares, shortestPath);\n      }\n    });\n\n  };\n\n  handleSquareTypeChoice = (event) => {\n    this.setState({ selectedSquareType: event.target.value });\n  };\n\n  animateSolving = async (squares, visitedSquares) => {\n    const DELAY_BETWEEN_SQUARE_ANIMATION = 3;\n    return new Promise((resolve) => {\n      for (let i = 0; i < visitedSquares.length; i++) {\n        let currentSquare = visitedSquares[i];\n        setTimeout(() => {\n          squares[currentSquare.id.row][\n            currentSquare.id.col\n          ].isInSearchArea = true;\n          this.setState({ squares: squares });\n        }, DELAY_BETWEEN_SQUARE_ANIMATION * (i + 1));\n        setTimeout(\n          resolve,\n          DELAY_BETWEEN_SQUARE_ANIMATION * visitedSquares.length\n        );\n      }\n    });\n  };\n\n  animateShortestPath = (squares, shortestPath) => {\n    const DELAY_BETWEEN_SQUARE_ON_PATH_ANIMATION = 100;\n    for (let i = 0; i < shortestPath.length - 1; i++) {\n      setTimeout(() => {\n        let currentSquare = shortestPath[i];\n        //TODO: Timeout not working properly? Maybe problem with this.state.squares?\n        squares[currentSquare.id.row][\n          currentSquare.id.col\n        ].isOnShortestPath = true;\n        this.setState({ squares });\n      }, DELAY_BETWEEN_SQUARE_ON_PATH_ANIMATION * (i + 1));\n    }\n  };\n\n  eraseSearchAreaWithShortestPath = () => {\n    let squares = this.state.squares;\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLS; j++) {\n        squares[i][j].hasBeenVisited = false;\n        squares[i][j].isInSearchArea = false;\n        squares[i][j].isOnShortestPath = false;\n      }\n    }\n    this.setState({ squares: squares });\n  }\n\n  handleClickOnSquare = (idOfClickedSquare) => {\n    let squares = this.state.squares;\n    //TODO: ADD start node and finish node from start\n    const oldStartingSquare = this.getStartingSquare(squares);\n    const oldFinishSquare = this.getFinishSquare(squares);\n    //TODO: Proper refactoring needed\n    if (\n      idOfClickedSquare !== oldStartingSquare.id &&\n      idOfClickedSquare !== oldFinishSquare.id\n    ) {\n      if (this.state.selectedSquareType === \"start\") {\n        squares[oldStartingSquare.id.row][\n          oldStartingSquare.id.col\n        ].isStart = false;\n      }\n      if (this.state.selectedSquareType === \"finish\") {\n        squares[oldFinishSquare.id.row][\n          oldFinishSquare.id.col\n        ].isFinish = false;\n      }\n\n      squares[idOfClickedSquare.row][idOfClickedSquare.col] = {\n        ... squares[idOfClickedSquare.row][idOfClickedSquare.col],\n        id: { row: idOfClickedSquare.row, col: idOfClickedSquare.col },\n        isStart: this.state.selectedSquareType === \"start\" ? true : false,\n        isFinish: this.state.selectedSquareType === \"finish\" ? true : false,\n      };\n    }\n\n    if (this.state.selectedSquareType === \"barrier\"){\n      squares[idOfClickedSquare.row][idOfClickedSquare.col].isBarrier = !squares[idOfClickedSquare.row][idOfClickedSquare.col].isBarrier\n    }\n\n    this.setState({ squares: squares });\n    this.eraseSearchAreaWithShortestPath();\n  };\n\n  render() {\n    const {\n      squares,\n      selectedSquareType,\n      wasSolved,\n      squaresForAnimation,\n      shortestPath,\n    } = this.state;\n    return (\n      <div className=\"App\">\n        <div className=\"navbar\">\n          <ul>\n            <li>Algo Visualizer</li>\n            <li>Shortest Path</li>\n          </ul>\n        </div>\n        <div className=\"solve-section\">\n          <div className=\"select-box\">\n            <label>Choose square: </label>\n            <select className=\"select\" onChange={this.handleSquareTypeChoice}>\n              <option value=\"start\">Start</option>\n              <option value=\"finish\">Finish</option>\n              <option value=\"barrier\">Barrier</option>\n            </select>\n          </div>\n          <div>\n          <button className=\"solve-button\" onClick={this.handleSolveClick}>\n            Find shortest path\n          </button>\n        </div>\n        </div>\n        <div className=\"tablePosition\">\n          <Table\n            squares={squares}\n            selectedSquareType={selectedSquareType}\n            wasSolved={wasSolved}\n            squaresForAnimation={squaresForAnimation}\n            shortestPath={shortestPath}\n            setInSearchAreaPropertyOfSquare={\n              this.setInSearchAreaPropertyOfSquare\n            }\n            handleClickOnSquare={this.handleClickOnSquare}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default PathFinder;\n","import React from \"react\";\nimport PathFinder from \"./PathFinder\";\n\nconst COLS = 20;\nconst ROWS = 20;\n\nclass App extends React.Component{\n\n  render() {\n    return(\n    <div>\n      <PathFinder></PathFinder>\n    </div>\n  );\n}\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}